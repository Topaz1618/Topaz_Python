# 冒泡排序
	list = [88,76,44,29,10]
	for i1 in range(len(list)-1):   #0-3
		# print(i1)
		for i2 in range(len(list)-i1-1):    #0-3
			if list[i2] > list[i2+1]:
				# print(list[i2],list[i2+1])
				tmp = list[i2+1]
				list[i2+1] = list[i2]
				list[i2] = tmp
# 选择排序
## 版本一
	data_set = [9, 1, 22, 31, 45, 3, 6, 2, 11]
	smallest_num_index = 0  # 初始列表最小值,默认为第一个
	loop_count = 0
	for j in range(len(data_set) - 1):
		print('列表', smallest_num_index)
		for i in range(j + 1, len(data_set)):  # 前面的就不取啦
			if data_set[i] < data_set[smallest_num_index]:  # 
				smallest_num_index = i  #拿到每次循环最小数的下标
			loop_count += 1
		else:  # 上面循环完就执行这里,汇报下当前循环的最小值
			print("====== 第 %s 次循环，找到倒数第 %s 最小值 %s 最小值下标 %s ======" % (j + 1, j + 1, data_set[smallest_num_index],smallest_num_index))
			tmp = data_set[smallest_num_index]  # 最小值存起来
			data_set[smallest_num_index] = data_set[j] 
			data_set[j] = tmp  
		print(data_set)
## 版本二
	list = [99,89,38,77,23,16,9]
	print(len(list))
	for i1 in range(len(list)-1):    #0-4
		for i2 in range(i1+1,len(list)):  #1-5
			if list[i2] < list[i1]:     #每个都和最前面的数比较
				tmp = list[i2]      #如果后面的比第一个值小就保存
				list[i2] = list[i1] #把大的数移到后面
				list[i1] = tmp      #把小的数复制给最前面
	print(list)
 
# 插入排序
	list = [88,76,44,29,10]
	source = [92, 77, 67, 8, 6, 84, 55, 85, 43, 67]
	for index in range(1, len(source)):
		current_val = source[index]  
		position = index    
		print(source)
		while position > 0 and source[position - 1] > current_val:  # 当前元素的左边的紧靠的元素比它大,要把左边的元素一个一个的往右移一位,给当前这个值插入到左边挪一个位置出来
			print("     Position: %s  右边值>: %s  " % (position,source[position - 1] ))
			source[position] = source[position - 1]  
			position -= 1  
		source[position] = current_val 
		
# 希尔排序
		import time, random
		source = [random.randrange(10 + i) for i in range(10)]  # 生成随机数列一组
		print(source)
		interval = int(len(source) / 2)  # 初始间隔：5
		print('间隔',interval)
		while interval > 0:
			print("---interval ---", interval)  #5 - 2 - 1
			# 对分组数据进行插入排序
			for index in range(len(source)):    #循环次数 = 列表长度
				if index + interval < len(source): 
					current_val = source[index]  # 当前下标元素
					if current_val > source[index + interval]: 
						source[index], source[index + interval] = source[index +interval], source[index]
			interval = int(interval / 2)
		else:  # 把基本排序好的数据再进行一次插入排序就好了
			for index in range(1, len(source)):
				current_val = source[index]  # 先记下来每次大循环走到的第几个元素的值
				position = index
				while position > 0 and source[position - 1] > current_val:  
					source[position] = source[position - 1]  # 把左边的一个元素往右移一位
					position -= 1 
				source[position] = current_val 
			print(source)



